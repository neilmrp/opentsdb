  /**
   * Encodes the given iterator.
   * @param context A non-null query context.
   * @param options Options, ignored.
   * @param result A non-null result.
   * @param iterator A non-null iterator.
   * @return A data protobuf object.
   */
  TimeSeriesData serializeGivenTimes(final QueryContext context,
                           final SerdesOptions options,
                           final QueryResult result,
                           final TypedTimeSeriesIterator<? extends TimeSeriesDataType> iterator,
                           final TimeStampPB.TimeStamp first,
                           final TimeStampPB.TimeStamp last) {
    final long span;
    switch(result.resolution()) {
      case NANOS:
      case MICROS:
        long seconds = last.epoch() -
                first.epoch();
        long ns = last.nanos() -
                first.nanos();
        span = (seconds * 1000L * 1000L * 1000L) + ns;
        break;
      case MILLIS:
        span = last.epoch() -
                first.epoch();
        break;
      default:
        span = last.epoch() -
                first.epoch();
    }
    byte encode_on = NumericCodec.encodeOn(span, NumericCodec.LENGTH_MASK);

    final Map<Integer, ByteArrayOutputStream> summary_streams =
            Maps.newHashMap();
    try {
      long previous_offset = -1;
      while (iterator.hasNext()) {
        @SuppressWarnings("unchecked")
        final TimeSeriesValue<NumericSummaryType> value =
                (TimeSeriesValue<NumericSummaryType>) iterator.next();
        if (value.timestamp().compare(Op.LT, first)) {
          continue;
        }
        if (value.timestamp().compare(Op.GT, last)) {
          break;
        }

        long current_offset = offset(first,
                value.timestamp(), result.resolution());
        if (current_offset == previous_offset) {
          throw new SerdesException("With results set to a resolution of "
                  + result.resolution() + " one or more data points with "
                  + "duplicate timestamps would be written at offset: "
                  + current_offset);
        }
        previous_offset = current_offset;

        if (value.value() == null) {
          // so, if we have already populated our summaries with nulls we
          // can fill with nulls. But at the start of the iteration we
          // don't know what to fill with.
          for (final Entry<Integer, ByteArrayOutputStream> entry :
                  summary_streams.entrySet()) {
            ByteArrayOutputStream baos = entry.getValue();
            final byte flags = NumericCodec.FLAG_FLOAT;
            baos.write(Bytes.fromLong(
                    (current_offset << NumericCodec.FLAG_BITS) | flags),
                    8 - encode_on, encode_on);
          }
          continue;
        }

        for (final int summary : value.value().summariesAvailable()) {
          ByteArrayOutputStream baos = summary_streams.get(summary);
          if (baos == null) {
            baos = new ByteArrayOutputStream();
            summary_streams.put(summary, baos);
          }

          NumericType val = value.value().value(summary);
          if (val == null) {
            // length of 0 + float flag == null value, so nothing following
            final byte flags = NumericCodec.FLAG_FLOAT;
            baos.write(Bytes.fromLong(
                    (current_offset << NumericCodec.FLAG_BITS) | flags),
                    8 - encode_on, encode_on);
          } else if (val.isInteger()) {
            final byte[] vle = NumericCodec.vleEncodeLong(val.longValue());
            final byte flags = (byte) (vle.length - 1);
            baos.write(Bytes.fromLong(
                    (current_offset << NumericCodec.FLAG_BITS) | flags),
                    8 - encode_on, encode_on);
            baos.write(vle);
          } else {
            final double v = val.doubleValue();
            final byte[] vle = NumericType.fitsInFloat(v) ?
                    Bytes.fromInt(Float.floatToIntBits((float) v)) :
                    Bytes.fromLong(Double.doubleToLongBits(v));
            final byte flags = (byte) ((vle.length - 1) | NumericCodec.FLAG_FLOAT);
            baos.write(Bytes.fromLong(
                    (current_offset << NumericCodec.FLAG_BITS) | flags),
                    8 - encode_on, encode_on);
            baos.write(vle);
          }
        }
      }
    } catch (IOException e) {
      throw new SerdesException("Unexppected exception serializing "
              + "iterator: " + iterator, e);
    }

    final NumericSummarySegment.Builder segment_builder =
            NumericSummarySegment.newBuilder()
                    .setEncodedOn(encode_on)
                    .setResolution(result.resolution().ordinal());
    for (final Entry<Integer, ByteArrayOutputStream> entry :
            summary_streams.entrySet()) {
      segment_builder.addData(NumericSummary.newBuilder()
              .setSummaryId(entry.getKey())
              // TODO - can I wrap???
              .setData(ByteString.copyFrom(entry.getValue().toByteArray())));
    }

    final TimeStampPB.TimeStamp.Builder start = TimeStampPB.TimeStamp.newBuilder()
            .setEpoch(first.epoch())
            .setNanos(first.nanos());
    if (context.query().getTimezone() != null) {
      start.setZoneId(context.query().getTimezone().toString());
    }

    final TimeStampPB.TimeStamp.Builder end = TimeStampPB.TimeStamp.newBuilder()
            .setEpoch(last.epoch())
            .setNanos(last.nanos());
    if (context.query().getTimezone() != null) {
      end.setZoneId(context.query().getTimezone().toString());
    }

    return TimeSeriesData.newBuilder()
            .setType(NumericSummaryType.TYPE.getRawType().getName())
            .addSegments(TimeSeriesDataSegment.newBuilder()
                    .setStart(start)
                    .setEnd(end)
                    .setData(Any.pack(segment_builder.build())))
            .build();
  }